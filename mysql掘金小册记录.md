看掘金小册MySQL问题记录
## 收获
### 1.进程名是什么
mysqld是服务器进程，一般启动服务器上的安装目录下bin下的mysqld就OK了

mysql是客户端进程的默认名称

mysql_safe是一个启动脚本，会间接的调用mysqld,还顺便启动了另外一个监控进程，


`mysql.server`也是一个启动脚本，是个链接文件，实际是../support-files/mysql.server,会间接的调用mysqld_safe,

	mysql.server start 启动服务器程序

mysqld_multi 可执行文件可以对每一个服务器进程的启动或停止进行监控。

### 2.启动选项和系统变量
变量分为全局变量和当前会话session变量，一般show看的都是session的变量

### 3.字符集和比较规则
字符集即描述某个字符范围的编码规则，即一个字符包含的字符范围，常用的unicode字符集

比较规则collation，即直接比较两个字符对应的二进制编码的大小，不过对于大小写或者汉字的字符的比较规则 就比较麻烦了。

GBK包含了GB2312字符，作了扩充。

从客户端发往服务器中间会经过`character_set_client` 客户端发送请求用的字符集`character_set_connection` 连接中使用的字符集，`character_set_results`服务器返回使用的字符集

所以`set names 字符集`就相当于设置了这3类字符集。

### 4.InnoDB一条记录存储结构
将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，innodb中页的大小一般为16kb.
一个汉字在不同的编码下，字符是不一样的，所对应的字节数根据字符改变，

分为4个行格式，compact分为2部分额外信息+真实数据

额外信息：
	


### 5.页记录
Innodb都是以页为单位存放数据，页号是唯一的，数据页之间形成了一个双链表用上一个和下一个页的属性关联起来。通过`主键`查找某条记录时在页目录中使用二分法快速定位到对应的槽，再遍历槽对应分组中的记录找到对应记录。

### 6.B+树索引
对于主键列的查找，可以通过定位页定位槽找到，然而对于非主键列则需要去每一页里的每行记录去查找，由此发展出了索引，
索引是对页做了个页目录，包括页里最小的主键值和页号，
聚簇索引:根据主键值做的B+树，叶子节点即数据记录

二级索引：列上的索引，叶子节点是当前列+主键，回表去聚簇索引上再找到对应的记录

联合索引：以c2列和c3列的大小为排序规则建立的B+树，即先按C2列的值进行排序，

myisam的索引，是按照记录的插入顺序单独存储在一个文件中，即数据文件，通过行号直接找记录，索引是个单独的文件，

Innodb和myisam会自动为主键或声明为unique的列去建立B+树索引，

每建立一个索引都要为它建立一颗B+树，每一颗B+树的每一个节点都是一个数据页，按从小到大的顺序排好序，

SQL语句里没有按索引列的顺序写时不会影响到索引的使用，因为MySQL有个查询优化器来决定先使用哪个搜索条件。
全值匹配

匹配最左边的列,类似name="",（按name，age的索引）

匹配列前缀，类似like "As%"

匹配范围值,类似 name>'A' and name <'B' and birthday>'1987'

匹配某一列并范围匹配另外一列，类似name='A' and birthday<'1987'

联合索引的排序，
	
* 规定各个列排序规则一致，如都是asc 或者都是desc才能用上索引。
* where子句中出现非排序使用到的索引列，orderby排序也不会用到
* 排序里包含非同一个索引的列也用不到索引，原因是联合索引的B+树是按联合索引的列建立的，不属于一个联合索引中的列
* 必须保证索引列是以单独列的形式出现
* 排序列不能使用复杂的表达式

分组列的顺序也要和索引列的顺序一致

回表的代价：
	
访问二级索引会使用顺序I/O,聚簇索引会使用随机I/O；查询优化器会对表中的记录计算统计数据再计算回表的记录数，需要回表的记录数越多就越倾向使用全表扫描，反之倾向使用二级索引+回表。所以如果加了limit回表的记录少了就会使用二级索引+回表的方式。


覆盖索引:即查询的列表里只有联合索引的列，这样就不用回表查了

列的基数指的是某一列中不重复数据的个数，如2，5，8，2，5，8基数是3，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中，对基数小的列建立索引是没用的。

索引字符串值的前缀，如`KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)` 只保留记录的前10个字符的编码。不过这样无法包含完整的列信息了。

索引列在比较表达式中单独出现

主键具有auto_increment属性，因为innodb是按主键从小到大排序。

### 6.数据库和文件系统的关系
在启动时会到文件系统的某个目录下加载一些文件，之后运行过程中产生的数据也都会存储到这个目录下，即数据目录，对应的系统变量是datadir

表在文件系统中的表示
表结构的定义 .frm

表中的数据,不同的存储引擎不同
#### innodb
innodb有个表空间/文件空间，对应文件系统上一个或多个真实文件

系统表空间，默认情况下会有个ibdata1，在5.5.7到5.6.6之间的版本，表中的数据都会默认存储到这个空间。

独立表空间，在5.6.6及之后的版本，各个表的数据会建立一个独立表空间，即`.idb`的扩展名。这个存储可以在配置文件里由`innodb_file_per_table`控制，=0是使用系统表空间，=1使用独立表空间。这个配置只对新表起作用，对于已经存在的表可以通过`alter table tablespace innodb_system`

#### myisam
没有所谓的表空间，表的存储会有3个文件`.frm` `.MYD`数据文件 `.MYI`索引文件。

#### 系统数据库
* mysql:存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息
* information_schema:保存着MySQL服务器维护的所有其他数据库的信息，称为元数据
* performance_schema:保存服务器运行过程中的一些状态信息，算是性能监控，包括统计最近执行了哪些语句
* sys：主要是通过视图的形式把information_schema和performance_schema结合起来，可以更方便的了解服务器的性能信息。

### 表空间
连续物理存储的64个页组成区，256个区组成一个组，区是为了可以用顺序I/O,为了方便管理这些区，设计了一个称为XDES Entry的结构，每个区都对应着一个此结构，


### 8.单表访问方法

#### const
常数级访问，索引的值与常数进行等值比较，如ID=2233；只会找到一条

#### ref
普通的二级索引可能匹配到多条连续的记录，

* 对于某个包含多个索引列的二级索引来说，只要最左边的连续索引列是与常数的等值比较就可能是ref的访问方法；但是如果最左边的连续索引并不全部是等值比较的话就不是ref了

#### ref_or_null
找某个二级索引列的值等于常数，还想找该列的值为null的

#### range
范围匹配

#### index
只遍历二级索引记录的方式称为index,
例子：
	
	SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
	遍历了二级索引idx_key_part(key_part1, key_part2, key_part3),



## 问题记录
### 1.进程通信问题
里面说客户端和服务端通讯的几种方式里的unix域套接字文件，是怎么做的？

这个要求服务器进程和客户端进程都运行在同一台操作系统Unix上，可以使用`unix域套接字文件`来进行进程间通讯， 个人理解socket也是基于tcp/ip 来通信的啊 

个人本地的/tmp/mysql.sock 是没权限打开的


### 2.高速缓存问题
说是从5.7。20开始不推荐使用高速缓存，在8.0里删除了高速缓存
？？？？

### 3.表空间
直属于表空间的3个链表是哪些，




### 4.索引疑问？
针对二级索引，是按UID层级分，然后怎么和主键ID连起来的？

对于一张表，answer，UID单独建了一个索引，uid+addtime建了联合索引，

那对于sql select count(*) from answer where uid=555 用的是哪个索引 




一个Unix时间戳的值转化为日期：
